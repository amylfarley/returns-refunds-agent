"""
Standalone Strands Agent: full_featured_returns_agent
Generated by AgentCore MCP Server

Integrations:
- Memory: Enabled
- Gateway: Enabled
- Knowledge Base: Enabled
"""

import os
import json
from strands import Agent, tool
from strands.models import BedrockModel
from strands_tools import retrieve
from strands_tools import current_time
from strands.tools.mcp import MCPClient
from mcp.client.streamable_http import streamablehttp_client
import requests
from bedrock_agentcore.memory.integrations.strands.config import AgentCoreMemoryConfig, RetrievalConfig
from bedrock_agentcore.memory.integrations.strands.session_manager import AgentCoreMemorySessionManager
from datetime import datetime

# Constants
MODEL_ID = "us.anthropic.claude-sonnet-4-5-20250929-v1:0"
REGION = "us-west-2"
SESSION_ID = "default-session"
ACTOR_ID = "default-actor"

# Model configuration
bedrock_model = BedrockModel(model_id=MODEL_ID, temperature=0.3)

# ============================================================================
# LOAD CONFIGURATION FROM FILES
# ============================================================================

print("Loading configuration files...")

# Load Knowledge Base ID from kb_config.json
try:
    with open('kb_config.json') as f:
        kb_config = json.load(f)
        kb_id = kb_config['knowledge_base_id']
        print(f"‚úì Knowledge Base ID loaded: {kb_id}")
except FileNotFoundError:
    kb_id = os.environ.get("KNOWLEDGE_BASE_ID", "YOUR_KB_ID_HERE")
    print(f"‚ö†Ô∏è  kb_config.json not found, using env/default: {kb_id}")

# Load Memory ID from memory_config.json
try:
    with open('memory_config.json') as f:
        memory_config = json.load(f)
        memory_id = memory_config['memory_id']
        print(f"‚úì Memory ID loaded: {memory_id}")
except FileNotFoundError:
    memory_id = os.environ.get("MEMORY_ID")
    print(f"‚ö†Ô∏è  memory_config.json not found, using env: {memory_id}")

# Load Gateway configuration from gateway_config.json
try:
    with open('gateway_config.json') as f:
        gateway_config = json.load(f)
        gateway_url = gateway_config['gateway_url']
        print(f"‚úì Gateway URL loaded: {gateway_url}")
except FileNotFoundError:
    gateway_url = os.environ.get("GATEWAY_URL")
    print(f"‚ö†Ô∏è  gateway_config.json not found, using env: {gateway_url}")

# Load Cognito configuration from cognito_config.json
try:
    with open('cognito_config.json') as f:
        cognito_config = json.load(f)
        cognito_client_id = cognito_config['client_id']
        cognito_client_secret = cognito_config['client_secret']
        cognito_discovery_url = cognito_config['discovery_url']
        print(f"‚úì Cognito config loaded")
except FileNotFoundError:
    cognito_client_id = os.environ.get("COGNITO_CLIENT_ID")
    cognito_client_secret = os.environ.get("COGNITO_CLIENT_SECRET")
    cognito_discovery_url = os.environ.get("COGNITO_DISCOVERY_URL")
    print(f"‚ö†Ô∏è  cognito_config.json not found, using env variables")

print()

# ============================================================================
# GATEWAY HELPER FUNCTIONS
# ============================================================================

def get_cognito_token_with_scope(client_id, client_secret, discovery_url, scope):
    """Get Cognito bearer token with a specific OAuth scope"""
    # Extract token endpoint from discovery URL
    discovery_response = requests.get(discovery_url)
    token_endpoint = discovery_response.json()['token_endpoint']
    
    # Get token using client credentials flow
    response = requests.post(
        token_endpoint,
        data={
            'grant_type': 'client_credentials',
            'client_id': client_id,
            'client_secret': client_secret,
            'scope': scope
        },
        headers={'Content-Type': 'application/x-www-form-urlencoded'}
    )
    
    response.raise_for_status()
    return response.json()["access_token"]

def create_mcp_client():
    """Create MCP client for gateway access"""
    oauth_scopes = "gateway-api/read gateway-api/write"
    
    if not all([gateway_url, cognito_client_id, cognito_client_secret, cognito_discovery_url]):
        print("‚ö†Ô∏è  Gateway environment variables not set - gateway tools will not be available")
        return None
    
    try:
        token = get_cognito_token_with_scope(
            cognito_client_id,
            cognito_client_secret,
            cognito_discovery_url,
            oauth_scopes
        )
        print(f"‚úì Gateway configured: {gateway_url}")
        return MCPClient(
            lambda: streamablehttp_client(
                gateway_url,
                headers={"Authorization": f"Bearer {token}"},
            )
        )
    except Exception as e:
        print(f"‚ö†Ô∏è  Failed to create MCP client: {e}")
        return None

# ============================================================================
# MEMORY CONFIGURATION
# ============================================================================

def create_memory_session_manager(mem_id: str, session_id: str = SESSION_ID, actor_id: str = ACTOR_ID):
    """Create AgentCore Memory session manager"""
    agentcore_memory_config = AgentCoreMemoryConfig(
        memory_id=mem_id,
        session_id=session_id,
        actor_id=actor_id,
        retrieval_config={
        f"app/{actor_id}/semantic": RetrievalConfig(top_k=3),
        f"app/{actor_id}/preferences": RetrievalConfig(top_k=3),
        f"app/{actor_id}/{session_id}/summary": RetrievalConfig(top_k=2),
        }
    )
    
    return AgentCoreMemorySessionManager(
        agentcore_memory_config=agentcore_memory_config,
        region_name=REGION
    )

# System prompt
system_prompt = f"""You are a returns assistant with memory and order lookup capabilities. Remember customer preferences, look up order details, and use the retrieve tool to access Amazon return policy documents for accurate information.

When using the retrieve tool, always pass these parameters:
- knowledgeBaseId: {kb_id}
- region: {REGION}
- text: the search query
- Gateway tools for external operations
- Customer conversation history and preferences through memory"""

# Custom tool definitions
@tool
def check_return_eligibility(purchase_date: str, category: str) -> dict:
    """Check if an item is eligible for return based on purchase date and category"""
    try:
        purchase_dt = datetime.strptime(purchase_date, '%Y-%m-%d')
        days_since_purchase = (datetime.now() - purchase_dt).days
        return_windows = {'electronics': 30, 'clothing': 30, 'books': 30, 'grocery': 30, 'jewelry': 30, 'default': 30}
        window = return_windows.get(category.lower(), return_windows['default'])
        if days_since_purchase < 0:
            return {'eligible': False, 'reason': 'Purchase date is in the future', 'days_remaining': 0}
        elif days_since_purchase <= window:
            return {'eligible': True, 'reason': f'Within {window}-day return window', 'days_remaining': window - days_since_purchase}
        else:
            return {'eligible': False, 'reason': f'Exceeded {window}-day return window', 'days_remaining': 0}
    except ValueError:
        return {'eligible': False, 'reason': 'Invalid date format. Use YYYY-MM-DD', 'days_remaining': 0}

@tool
def calculate_refund_amount(original_price: float, condition: str, return_reason: str) -> dict:
    """Calculate refund amount based on price, condition, and return reason"""
    if original_price < 0:
        return {'refund_amount': 0.0, 'deduction': 0.0, 'reason': 'Invalid price'}
    condition_deductions = {'new': 0.0, 'opened': 0.0, 'used': 0.20, 'damaged': 0.50}
    full_refund_reasons = ['defective', 'wrong_item', 'not_as_described']
    if return_reason.lower() in full_refund_reasons:
        refund_amount = original_price
        deduction = 0.0
        reason = 'Full refund - seller error'
    else:
        deduction_rate = condition_deductions.get(condition.lower(), 0.20)
        deduction = original_price * deduction_rate
        refund_amount = original_price - deduction
        reason = f'{int(deduction_rate * 100)}% deduction for {condition} condition'
    return {'refund_amount': round(refund_amount, 2), 'deduction': round(deduction, 2), 'original_price': original_price, 'reason': reason}

@tool
def format_policy_response(policy_text: str, customer_question: str = '') -> str:
    """Format policy information in a customer-friendly way"""
    formatted = 'üìã Return Policy Information\n' + '=' * 50 + '\n\n'
    if customer_question:
        formatted += f'Regarding: {customer_question}\n\n'
    lines = policy_text.strip().split('\n')
    for line in lines:
        line = line.strip()
        if not line:
            formatted += '\n'
        elif line.isupper() or line.endswith(':'):
            formatted += f'\n{line}\n'
        elif line.startswith('-') or line.startswith('‚Ä¢'):
            formatted += f'  {line}\n'
        else:
            formatted += f'{line}\n'
    formatted += '\n' + '=' * 50 + '\n' + 'üí° Tip: If you have specific questions about your return, I can help!\n'
    return formatted


def run_agent(user_input: str, session_id: str = SESSION_ID, actor_id: str = ACTOR_ID):
    """Run the agent with user input"""
    
    # Build tools list
    custom_tools = [retrieve, current_time, check_return_eligibility, calculate_refund_amount, format_policy_response]
    
    # Configure memory
    if not memory_id:
        print("‚ö†Ô∏è  MEMORY_ID not set - agent will run without memory")
        session_manager = None
    else:
        session_manager = create_memory_session_manager(memory_id, session_id, actor_id)
        print(f"‚úì Memory configured: {memory_id}")
    
    # Try to add gateway tools
    mcp_client = create_mcp_client()
    
    if mcp_client:
        try:
            # Keep MCP client active during agent execution
            with mcp_client:
                # Get gateway tools from MCP client
                gateway_tools = list(mcp_client.list_tools_sync())
                print(f"‚úì Loaded {len(gateway_tools)} gateway tools")
                
                # Create agent with gateway tools
                agent = Agent(
                    model=bedrock_model,
                    tools=custom_tools + gateway_tools,
                    system_prompt=system_prompt,
                    session_manager=session_manager
                )
                
                response = agent(user_input)
                return response.message["content"][0]["text"]
        except Exception as e:
            print(f"‚ö†Ô∏è  Failed to use gateway tools: {e}")
            # Fall back to agent without gateway tools
    
    # Create agent without gateway tools (fallback or no gateway)
    agent = Agent(
        model=bedrock_model,
        tools=custom_tools,
        system_prompt=system_prompt,
        session_manager=session_manager
    )
    
    response = agent(user_input)
    return response.message["content"][0]["text"]

if __name__ == "__main__":
    # Example usage
    user_query = "Hello, how can you help me?"
    result = run_agent(user_query, actor_id="user_001")
    print("\n" + "="*80)
    print("AGENT RESPONSE:")
    print("="*80)
    print(result)
