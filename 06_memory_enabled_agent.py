"""
Standalone Strands Agent: returns_agent_with_memory
Generated by AgentCore MCP Server

Integrations:
- Memory: Enabled
- Gateway: Disabled
- Knowledge Base: Enabled
"""

import os
import json
from strands import Agent, tool
from strands.models import BedrockModel
from strands_tools import retrieve
from strands_tools import current_time
from bedrock_agentcore.memory.integrations.strands.config import AgentCoreMemoryConfig, RetrievalConfig
from bedrock_agentcore.memory.integrations.strands.session_manager import AgentCoreMemorySessionManager
from datetime import datetime

# Constants
MODEL_ID = "us.anthropic.claude-sonnet-4-5-20250929-v1:0"
REGION = "us-west-2"
SESSION_ID = "default-session"
ACTOR_ID = "default-actor"

# Model configuration
bedrock_model = BedrockModel(model_id=MODEL_ID, temperature=0.3)

# ============================================================================
# LOAD CONFIGURATION FROM FILES
# ============================================================================

# Load Knowledge Base ID from kb_config.json
try:
    with open('kb_config.json') as f:
        kb_config = json.load(f)
        kb_id = kb_config['knowledge_base_id']
        print(f"‚úì Knowledge Base ID loaded: {kb_id}")
except FileNotFoundError:
    kb_id = os.environ.get("KNOWLEDGE_BASE_ID", "YOUR_KB_ID_HERE")
    print(f"‚ö†Ô∏è  kb_config.json not found, using env/default: {kb_id}")

# Load Memory ID from memory_config.json
try:
    with open('memory_config.json') as f:
        memory_config = json.load(f)
        memory_id = memory_config['memory_id']
        print(f"‚úì Memory ID loaded: {memory_id}")
except FileNotFoundError:
    memory_id = os.environ.get("MEMORY_ID")
    print(f"‚ö†Ô∏è  memory_config.json not found, using env: {memory_id}")

# ============================================================================
# MEMORY CONFIGURATION
# ============================================================================

def create_memory_session_manager(mem_id: str, session_id: str = SESSION_ID, actor_id: str = ACTOR_ID):
    """Create AgentCore Memory session manager"""
    agentcore_memory_config = AgentCoreMemoryConfig(
        memory_id=mem_id,
        session_id=session_id,
        actor_id=actor_id,
        retrieval_config={
        f"app/{actor_id}/semantic": RetrievalConfig(top_k=3),
        f"app/{actor_id}/preferences": RetrievalConfig(top_k=3),
        f"app/{actor_id}/{session_id}/summary": RetrievalConfig(top_k=2),
        }
    )
    
    return AgentCoreMemorySessionManager(
        agentcore_memory_config=agentcore_memory_config,
        region_name=REGION
    )

# System prompt
system_prompt = f"""You are a personalized returns assistant who remembers customer preferences and history. Use the retrieve tool to access Amazon return policy documents for accurate information.

When using the retrieve tool, always pass these parameters:
- knowledgeBaseId: {kb_id}
- region: {REGION}
- text: the search query
- Customer conversation history and preferences through memory"""

# Custom tool definitions
@tool
def check_return_eligibility(purchase_date: str, category: str) -> dict:
    """
    Check if an item is eligible for return based on purchase date and category.
    
    Args:
        purchase_date: Purchase date in YYYY-MM-DD format
        category: Product category (e.g., 'electronics', 'clothing', 'books')
    
    Returns:
        Dictionary with eligibility status and reason
    """
    try:
        purchase_dt = datetime.strptime(purchase_date, '%Y-%m-%d')
        days_since_purchase = (datetime.now() - purchase_dt).days
        
        # Return windows by category
        return_windows = {
            'electronics': 30,
            'clothing': 30,
            'books': 30,
            'grocery': 30,
            'jewelry': 30,
            'default': 30
        }
        
        window = return_windows.get(category.lower(), return_windows['default'])
        
        if days_since_purchase < 0:
            return {
                'eligible': False,
                'reason': 'Purchase date is in the future',
                'days_remaining': 0
            }
        elif days_since_purchase <= window:
            return {
                'eligible': True,
                'reason': f'Within {window}-day return window',
                'days_remaining': window - days_since_purchase
            }
        else:
            return {
                'eligible': False,
                'reason': f'Exceeded {window}-day return window',
                'days_remaining': 0
            }
    except ValueError:
        return {
            'eligible': False,
            'reason': 'Invalid date format. Use YYYY-MM-DD',
            'days_remaining': 0
        }

@tool
def calculate_refund_amount(original_price: float, condition: str, return_reason: str) -> dict:
    """
    Calculate refund amount based on price, condition, and return reason.
    
    Args:
        original_price: Original purchase price
        condition: Item condition ('new', 'opened', 'used', 'damaged')
        return_reason: Reason for return ('defective', 'wrong_item', 'changed_mind', 'not_as_described')
    
    Returns:
        Dictionary with refund amount and breakdown
    """
    if original_price < 0:
        return {
            'refund_amount': 0.0,
            'deduction': 0.0,
            'reason': 'Invalid price'
        }
    
    # Condition-based deductions
    condition_deductions = {
        'new': 0.0,
        'opened': 0.0,
        'used': 0.20,  # 20% deduction
        'damaged': 0.50  # 50% deduction
    }
    
    # Reason-based adjustments (defective/wrong items get full refund)
    full_refund_reasons = ['defective', 'wrong_item', 'not_as_described']
    
    if return_reason.lower() in full_refund_reasons:
        # Full refund regardless of condition for seller errors
        refund_amount = original_price
        deduction = 0.0
        reason = 'Full refund - seller error'
    else:
        # Apply condition-based deduction
        deduction_rate = condition_deductions.get(condition.lower(), 0.20)
        deduction = original_price * deduction_rate
        refund_amount = original_price - deduction
        reason = f'{int(deduction_rate * 100)}% deduction for {condition} condition'
    
    return {
        'refund_amount': round(refund_amount, 2),
        'deduction': round(deduction, 2),
        'original_price': original_price,
        'reason': reason
    }

@tool
def format_policy_response(policy_text: str, customer_question: str = '') -> str:
    """
    Format policy information in a customer-friendly way.
    
    Args:
        policy_text: Raw policy text from knowledge base
        customer_question: Optional customer question for context
    
    Returns:
        Formatted, customer-friendly policy response
    """
    # Add friendly header
    formatted = 'üìã Return Policy Information\n'
    formatted += '=' * 50 + '\n\n'
    
    if customer_question:
        formatted += f'Regarding: {customer_question}\n\n'
    
    # Clean up and format the policy text
    lines = policy_text.strip().split('\n')
    
    for line in lines:
        line = line.strip()
        if not line:
            formatted += '\n'
        elif line.isupper() or line.endswith(':'):
            # Treat as section header
            formatted += f'\n{line}\n'
        elif line.startswith('-') or line.startswith('‚Ä¢'):
            # Keep bullet points
            formatted += f'  {line}\n'
        else:
            # Regular text
            formatted += f'{line}\n'
    
    formatted += '\n' + '=' * 50 + '\n'
    formatted += 'üí° Tip: If you have specific questions about your return, I can help!\n'
    
    return formatted


def run_agent(user_input: str, session_id: str = SESSION_ID, actor_id: str = ACTOR_ID):
    """Run the agent with user input"""
    
    # Build tools list
    custom_tools = [retrieve, current_time, check_return_eligibility, calculate_refund_amount, format_policy_response]
    
    # Configure memory
    if not memory_id:
        print("‚ö†Ô∏è  MEMORY_ID not set - agent will run without memory")
        session_manager = None
    else:
        session_manager = create_memory_session_manager(memory_id, session_id, actor_id)
        print(f"‚úì Memory configured: {memory_id}")
    
    # Create agent
    agent = Agent(
        model=bedrock_model,
        tools=custom_tools,
        system_prompt=system_prompt,
        session_manager=session_manager
    )
    
    response = agent(user_input)
    return response.message["content"][0]["text"]

if __name__ == "__main__":
    # Example usage
    user_query = "Hello, how can you help me?"
    result = run_agent(user_query, actor_id="user_001")
    print("\n" + "="*80)
    print("AGENT RESPONSE:")
    print("="*80)
    print(result)
